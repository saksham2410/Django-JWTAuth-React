'use strict';

exports.__esModule = true;
exports.default = createPersistoid;

var _constants = require('./constants');

function createPersistoid(config) {
  // defaults
  var blacklist = config.blacklist || null;
  var whitelist = config.whitelist || null;
  var transforms = config.transforms || [];
  var throttle = config.throttle || 0;
  var storageKey = '' + (config.keyPrefix !== undefined ? config.keyPrefix : _constants.KEY_PREFIX) + config.key;

  var storage = config.storage;

  // initialize stateful values
  var lastState = {};
  var keysToProcess = [];
  var timeIterator = null;

  var update = function update(state) {
    Object.keys(state).forEach(function (key) {
      var subState = state[key];
      if (!passWhitelistBlacklist(key)) return; // is keyspace ignored? noop
      if (lastState[key] === state[key]) return; // value unchanged? noop
      if (keysToProcess.indexOf(key) !== -1) return; // is key already queued? noop
      keysToProcess.push(key); // add key to queue
    });

    // time iterator (read: throttle)
    if (timeIterator === null) {
      timeIterator = setInterval(function () {
        if (keysToProcess.length === 0) {
          if (timeIterator) clearInterval(timeIterator);
          timeIterator = null;
          return;
        }

        var key = keysToProcess.shift();
        var endState = transforms.reduce(function (subState, transformer) {
          return transformer.in(subState, key);
        }, lastState[key]);
        if (typeof endState !== 'undefined') stagedWrite(key, endState);
      }, throttle);
    }

    lastState = state;
  };

  var stagedState = {};
  function stagedWrite(key, endState) {
    try {
      stagedState[key] = serialize(endState);
    } catch (err) {
      console.error('redux-persist/createPersistoid: error serializing state', err);
    }
    if (keysToProcess.length === 0) {
      storage.setItem(storageKey, serialize(stagedState), onWriteFail);
    }
  }

  function passWhitelistBlacklist(key) {
    if (whitelist && whitelist.indexOf(key) === -1) return false;
    if (blacklist && blacklist.indexOf(key) !== -1) return false;
    return true;
  }

  function onWriteFail() {
    return function setError(err) {
      // @TODO add fail handlers (typically storage full)
      if (err && process.env.NODE_ENV !== 'production') {
        console.error('Error storing data', err);
      }
    };
  }

  // return `persistoid`
  return {
    update: update
  };
}

// @NOTE in the future this may be exposed via config


function serialize(data) {
  return JSON.stringify(data);
}